/* assets/intro/intro.js â€” INTRO (Option B: overlay generated by JS only)
   - Single source of truth: this script creates and controls the intro overlay.
   - Strict gating: phases start only after required assets are decoded.
   - Responsive: sizes derived from viewport (%), never fixed pixels.

   Timeline (your latest macro actions):
   G0: show 3 logos (motif L + texte + motif R), tremble, WITHOUT shards (>=2s)
   T0: preload shards in parallel
   G1: when shards ready -> fade texte -> shards
   P2: explode shards (1.5s), at 0.5 duration shards are at max distance
   P3: recoil + tremble (1s)
   T1: fade shards out (during/at end of P3)
   P3bis: merge motifs + zoom (900ms)
   P4: shockwave (short)
   P5: contemplation (2s)
   P6: fade out logos (700ms)
   P7: pause background only (1s)
   P8: laser curtain reveal (1s) -> show site
*/

(() => {
  const qs = (s, r=document) => r.querySelector(s);

  const BASE = 'assets/intro';
  const PATHS = {
    left:  `${BASE}/logo-motif-left.webp`,
    right: `${BASE}/logo-motif-right.webp`,
    text:  `${BASE}/logo-texte.webp`,
    meta:  `${BASE}/shards_meta.json`,
    shardsDir: `${BASE}/shards`,
    bg:    `assets/fond/fond-gris-h.webp`,
  };

  const DUR = {
    bootFade: 500,
    trembleMin: 2000,
    textToShards: 450,
    explode: 1500,
    recoil: 1000,
    shardsFade: 450,
    merge: 900,
    shock: 450,
    contemplate: 2000,
    fadeOut: 700,
    bgPause: 1000,
    reveal: 1000,
  };

  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  async function fetchJSON(url){
    const res = await fetch(url, { cache: 'no-store' });
    if (!res.ok) throw new Error(`fetch ${url} -> ${res.status}`);
    return await res.json();
  }

  function loadImage(url){
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.decoding = 'async';
      img.onload = async () => {
        try { if (img.decode) await img.decode(); } catch(_) {}
        resolve(img);
      };
      img.onerror = () => reject(new Error('Failed to load ' + url));
      img.src = url;
    });
  }

  function createOverlay(){
    const ov = document.createElement('div');
    ov.className = 'intro-overlay';
    ov.innerHTML = `
      <div class="intro-bg" aria-hidden="true">
        <div class="bg-layer bg-base"></div>
        <div class="bg-layer bg-glow"></div>
        <div class="bg-layer bg-noise"></div>
      </div>

      <div class="intro-stage" id="intro-stage">
        <div class="intro-logo-row" id="intro-row">
          <img id="intro-motif-left" class="intro-logo intro-motif" alt="" decoding="async" />
          <div class="intro-center" id="intro-center">
            <img id="intro-logo-text" class="intro-logo intro-text" alt="" decoding="async" />
            <div id="intro-shards" class="shards-box" aria-hidden="true"></div>
          </div>
          <img id="intro-motif-right" class="intro-logo intro-motif" alt="" decoding="async" />
        </div>

        <div id="intro-shockwave" aria-hidden="true"></div>
      </div>

      <div class="intro-reveal" id="intro-reveal" aria-hidden="true">
        <div class="laser-head"></div>
      </div>
    `;
    document.body.appendChild(ov);

    ov.querySelector('.bg-base').style.backgroundImage = `url('${PATHS.bg}')`;
    return ov;
  }

  // Responsive layout: guarantee left + center + right fit horizontally.
  function computeLayout(){
    const vw = Math.max(320, window.innerWidth);
    const vh = Math.max(480, window.innerHeight);

    // ratios (w/h)
    const arText = 16/9;
    const arMotif = 1/3;
    const gapCoef = 0.06; // proportional to height

    const totalCoef = (2*arMotif) + arText + gapCoef;

    const hFromWidth = (vw * 0.94) / totalCoef;
    const hFromHeight = vh * 0.56;

    const h = clamp(Math.min(hFromWidth, hFromHeight), 110, 560);
    const motifW = h * arMotif;
    const textW = h * arText;
    const gap = h * gapCoef;

    return {h, motifW, textW, gap};
  }

  function applyLayout(stage){
    const {h, motifW, textW, gap} = computeLayout();
    stage.style.setProperty('--logoH', `${h}px`);
    stage.style.setProperty('--motifW', `${motifW}px`);
    stage.style.setProperty('--textW', `${textW}px`);
    stage.style.setProperty('--logoGap', `${gap}px`);
  }

  function makeShardEl(src){
    const img = document.createElement('img');
    img.className = 'shard';
    img.decoding = 'async';
    img.alt = '';
    img.draggable = false;
    img.src = src;
    return img;
  }

  function setOpacity(el, v){
    el.style.opacity = String(v);
  }

  function setTrembleState(overlay, {textWeak=false, textStrong=false, motifWeak=false, motifStrong=false}){
    overlay.classList.toggle('t-text-weak', !!textWeak);
    overlay.classList.toggle('t-text-strong', !!textStrong);
    overlay.classList.toggle('t-motif-weak', !!motifWeak);
    overlay.classList.toggle('t-motif-strong', !!motifStrong);
  }

  function pingShock(shockEl){
    shockEl.classList.remove('ping');
    // force reflow
    void shockEl.offsetWidth;
    shockEl.classList.add('ping');
  }

  async function run(){
    const html = document.documentElement;
    html.classList.add('intro-active');

    const overlay = createOverlay();
    const stage = qs('#intro-stage', overlay);
    const row = qs('#intro-row', overlay);
    const center = qs('#intro-center', overlay);
    const imgL = qs('#intro-motif-left', overlay);
    const imgR = qs('#intro-motif-right', overlay);
    const imgT = qs('#intro-logo-text', overlay);
    const shardsBox = qs('#intro-shards', overlay);
    const reveal = qs('#intro-reveal', overlay);
    const shock = qs('#intro-shockwave', overlay);

    // assets
    imgL.src = PATHS.left;
    imgR.src = PATHS.right;
    imgT.src = PATHS.text;

    // layout
    const relayout = () => applyLayout(stage);
    relayout();
    window.addEventListener('resize', relayout, {passive:true});

    // Boot fade
    overlay.style.opacity = '0';
    requestAnimationFrame(() => {
      overlay.style.transition = `opacity ${DUR.bootFade}ms ease`;
      overlay.style.opacity = '1';
    });

    // Always start with no shards visible
    shardsBox.innerHTML = '';
    shardsBox.style.opacity = '0';
    imgT.style.opacity = '1';

    // === G0 ===
    // Motifs weak, Text weak before T0; minimum 2s
    setTrembleState(overlay, { textWeak:true, motifWeak:true });

    // Start loading core images early
    await Promise.allSettled([loadImage(PATHS.left), loadImage(PATHS.right), loadImage(PATHS.text)]);

    // === T0: preload shards (in parallel) ===
    let shardUrls = [];
    try{
      const meta = await fetchJSON(PATHS.meta);

      // Preferred: meta.files (exact filenames)
      if (Array.isArray(meta.files) && meta.files.length){
        shardUrls = meta.files.map(f => `${PATHS.shardsDir}/${f}`);
      } else if (Number(meta.count) > 0) {
        // fallback: shard_001.webp format
        const count = Number(meta.count);
        shardUrls = Array.from({length:count}, (_,i) => `${PATHS.shardsDir}/shard_${String(i+1).padStart(3,'0')}.webp`);
      }
    }catch(e){
      console.warn('[intro] shards_meta missing/invalid', e);
    }

    // From T0 -> P2: text "strong" (applied to center, so it affects shards too once they appear)
    setTrembleState(overlay, { textStrong:true, motifWeak:true });

    // Strict shard decode
    let shardOk = false;
    if (shardUrls.length){
      const results = await Promise.allSettled(shardUrls.map(loadImage));
      const ok = results.filter(r => r.status==='fulfilled').length;
      shardOk = ok === shardUrls.length;
      if (!shardOk) console.warn(`[intro] shards loaded ${ok}/${shardUrls.length}`);
    }

    // Ensure G0 lasts at least trembleMin total
    await sleep(DUR.trembleMin);

    // === G1: fade texte -> shards (only if shardOk) ===
    if (shardOk){
      shardsBox.innerHTML = '';
      shardUrls.forEach(u => shardsBox.appendChild(makeShardEl(u)));

      // fade out text, fade in shards
      imgT.style.transition = `opacity ${DUR.textToShards}ms ease`;
      shardsBox.style.transition = `opacity ${DUR.textToShards}ms ease`;
      imgT.style.opacity = '0';
      shardsBox.style.opacity = '1';
      await sleep(DUR.textToShards + 30);
    } else {
      // If shards missing, we still proceed (text stays visible) but skip explode/merge visual parts.
      imgT.style.opacity = '1';
      shardsBox.style.opacity = '0';
    }

    // === P2: explode shards (1.5s) ===
    // During P2 -> P3bis: motifs strong tremble
    setTrembleState(overlay, { textStrong:true, motifStrong:true });

    const shards = Array.from(shardsBox.querySelectorAll('img.shard'));

    if (shards.length){
      shards.forEach((s) => {
        s.style.position = 'absolute';
        s.style.inset = '0';
        s.style.transform = 'translate3d(0,0,0) rotate(0deg) scale(1)';
        s.style.opacity = '1';
      });

      const maxTravel = Math.max(stage.clientWidth, stage.clientHeight) * 1.6;

      shards.forEach((s, idx) => {
        const a = (idx / shards.length) * Math.PI*2;
        const dirx = Math.cos(a) + (Math.random()*2-1)*0.7;
        const diry = Math.sin(a) - 0.15 + (Math.random()*2-1)*0.55;
        const len = maxTravel * (0.7 + Math.random()*0.6);

        const tx = dirx * len;
        const ty = diry * len;
        const rot = (Math.random()*2-1) * (35 + Math.random()*70);
        const sc = 1 + Math.random()*0.35;

        s.style.transition = `transform ${DUR.explode}ms cubic-bezier(.2,.9,.2,1), opacity ${DUR.explode}ms ease`;
        s.style.transform = `translate3d(${tx}px, ${ty}px, 0) rotate(${rot}deg) scale(${sc})`;
      });

      // T0.5 marker: shards at max distance halfway through explode (no extra code needed)
      await sleep(DUR.explode);
    } else {
      await sleep(DUR.explode);
    }

    // === P3: recoil + tremblement (1s) ===
    row.classList.add('recoil');
    await sleep(DUR.recoil);
    row.classList.remove('recoil');

    // === T1: fade shards ===
    if (shards.length){
      shardsBox.style.transition = `opacity ${DUR.shardsFade}ms ease`;
      shardsBox.style.opacity = '0';
      await sleep(DUR.shardsFade + 30);
      shardsBox.innerHTML = ''; // remove to avoid clicks/overdraw
    }

    // === P3bis: merge motifs + zoom ===
    row.classList.add('merge');
    await sleep(DUR.merge);
    row.classList.remove('merge');

    // End of P3bis: stop all tremble (motifs stable, text irrelevant now)
    setTrembleState(overlay, { });

    // === P4: shockwave ===
    pingShock(shock);
    await sleep(DUR.shock);

    // === P5: contemplation ===
    await sleep(DUR.contemplate);

    // === P6: fade out logos (row) ===
    row.style.transition = `opacity ${DUR.fadeOut}ms ease`;
    row.style.opacity = '0';
    await sleep(DUR.fadeOut + 30);

    // === P7: pause background only ===
    await sleep(DUR.bgPause);

    // === P8: laser curtain reveal ===
    reveal.classList.add('on');
    reveal.classList.add('sweep');
    await sleep(DUR.reveal + 30);

    // Done
    html.classList.remove('intro-active');
    html.classList.add('intro-done');

    overlay.style.transition = 'opacity 400ms ease';
    overlay.style.opacity = '0';
    await sleep(420);
    overlay.remove();
  }

  try {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', run, {once:true});
    } else {
      run();
    }
  } catch(e){
    console.error('[intro] fatal', e);
    document.documentElement.classList.remove('intro-active');
    document.documentElement.classList.add('intro-done');
  }
})();
